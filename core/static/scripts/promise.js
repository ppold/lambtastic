// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice;

  define(function() {
    /*
     * Short implementation of the promise pattern
    */

    var DEFERRED, Promise, REJECTED, RESOLVED;

    DEFERRED = 0;
    REJECTED = 1;
    RESOLVED = 2;
    Promise = (function() {
      function Promise() {
        this.status = DEFERRED;
        this.response = null;
        this.resolvedCallbacks = [];
        this.rejectedCallbacks = [];
      }

      /**
       * Subscribes the callback to the promise's execution
       * @param  {Function} callback The function to execute when resolved
      */


      Promise.prototype.then = function(callback) {
        if (this.status === RESOLVED) {
          callback.apply(null, this.values);
        } else if (this.status === DEFERRED) {
          this.resolvedCallbacks.push(callback);
        }
        return this;
      };

      Promise.prototype.fail = function(callback) {
        if (this.status === REJECTED) {
          callback.apply(null, this.values);
        } else if (this.status === DEFERRED) {
          this.rejectedCallbacks.push(callback);
        }
        return this;
      };

      /**
       * Executes all the subscribed callbacks with the returned values
       * @param  {arguments} @values... List of arguments to send
      */


      Promise.prototype.resolve = function() {
        var callback, values, _i, _len, _ref;

        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.values = values;
        if (this.status === RESOLVED) {
          throw 'Promise already resolved!';
        } else if (this.status === REJECTED) {
          throw 'Can\'t resolve a promise that has been rejected!';
        }
        _ref = this.resolvedCallbacks;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          callback.apply(null, this.values);
        }
        this.resolvedCallbacks.length = 0;
        this.resolvedCallbacks = null;
        return this.status = RESOLVED;
      };

      Promise.prototype.reject = function() {
        var callback, values, _i, _len, _ref;

        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        this.values = values;
        if (this.status === REJECTED) {
          throw 'Promise already rejected!';
        } else if (this.status === RESOLVED) {
          throw 'Can\'t reject a promise that has been resolved!';
        }
        _ref = this.rejectedCallbacks;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          callback = _ref[_i];
          callback.apply(null, this.values);
        }
        this.rejectedCallbacks.length = 0;
        this.rejectedCallbacks = null;
        return this.status = REJECTED;
      };

      Promise.all = function(promises) {
        var completed, data, handler, length, promise, _i, _len;

        data = [];
        handler = function() {
          var rest;

          rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          data.push(rest);
          completed++;
          if (completed === length) {
            return promise.resolve(data);
          }
        };
        length = promises.length;
        completed = 0;
        for (_i = 0, _len = promises.length; _i < _len; _i++) {
          promise = promises[_i];
          promise.then(handler);
        }
        promise = new Promise();
        return promise;
      };

      return Promise;

    })();
    return Promise;
  });

}).call(this);
